# Gemini Instructions for ScriptHut

## Discussion Files

When having conversations, planning features, or documenting decisions, always create or update markdown files in the `.discussion/` directory at the project root.

Use descriptive filenames like `todos.md`, `architecture-decisions.md`, `feature-xyz.md`, etc.

## Project Context

ScriptHut is a Python web interface for managing and tracking jobs on remote HPC systems (Slurm, with PBS and ECS planned) over SSH. The codebase uses FastAPI, asyncssh, Pydantic, and HTMX.

## Architecture Principles

1. **Nothing runs on the head node except scheduling.** All user code (Python, R, etc.) must run as Slurm jobs on compute nodes. The only SSH commands ScriptHut runs directly on the head node are `sbatch`, `squeue`, `scancel`, `cat`, `mkdir`, and similar basic utilities. Never assume `python`, `R`, or other tools are available on the head node.

2. **Endogenous workflows.** Task sources can be generated by tasks themselves. A user points ScriptHut at a task source with a single "generator" task. That task runs on a compute node and produces a JSON file (in `~/.cache/scripthut/` on the cluster). ScriptHut then reads that JSON and schedules the actual workflow tasks. From ScriptHut's perspective, it's all just tasks and task sources — the generation is endogenous.

3. **Language agnostic.** ScriptHut doesn't care what language generates the task JSON. Python, R, Julia, bash — that's the user's choice. ScriptHut only cares about the JSON output format.

4. **Single polling loop.** One `poll_jobs()` loop drives all backend interaction — `squeue`, `sacct`, run status updates, external job tracking, and SSE notifications. There must never be competing polling loops or independent timers making SSH calls. Everything piggybacks on the single `poll_interval` cycle. Force-poll (`POST /poll`) wakes the same loop early rather than creating a parallel path.

5. **Passive SSE.** All SSE endpoints (`/jobs/stream`, `/runs/stream`, `/runs/{id}/events`) wait on `asyncio.Event` objects set by the poll loop or run manager. They never poll independently or make SSH calls. The frontend receives pushed updates — it doesn't pull.

## Key Conventions

- Type annotations on all functions
- Async/await for all I/O operations
- Pydantic models for configuration and validation
- Abstract base classes for extensible backends (`backends/base.py`)
- Tests use pytest + pytest-asyncio
